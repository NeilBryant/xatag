#!/usr/bin/env python

"""xatag - file tagging using extended attributes (xattr).

Usage:
  xatag [options] ([-a] | -l | -s | -S | -d) <tag> <file>... 
  xatag [options] ([-a] | -l | -s | -S | -d) <file>... -t <tag>...    
  xatag [options] ([-a] | -l | -s | -S | -d) <tag>...  -f <file>...
  xatag [options] [-i] <file>
  xatag [options] (-c | -C) <src> <dest>... [-t <tag>]...
  xatag [options] -D  <file>...
  xatag [options] -x  <tag>... | <query_string>
  xatag [options] -e  <tag>...           
  xatag [options] -m          
  xatag  -h | --help
  xatag  -V | --version

File Tagging Commands:
  -a --add          Add all of the TAG(s) to the FILE(s).  This is the
                    default command if you provide more than one argument.
  -i --interactive  Add and remove tags for FILE interactively.  This is the
                    default command if you provide only one argument.
  -l --list         List the tags currently written on FILE(s).  
  -s --set          Set the tags of the given FILE(s) to the TAG(s) given, erasing 
                    any previous xatag data in the extended attributes in the
                    same fields as new TAG(s).
  -S --set-all      Set the tags of the given FILE(s) to the TAG(s) given, erasing 
                    any previous xatag data in the extended attributes.
                    Equivalent to 'xatag -D <file>...; xatag -a <tag> <file>...'
  -d --delete       Remove all of the given TAG(s) to the given FILE(s).
  -D --delete-all   Remove all xatag tags from the FILE(s)
  -c --copy         Copy xatag fields from SRC to DEST(s)
  -C --copy-over    Copy xatag fields from SRC to DEST(s), erasing any 
                    previous xatag data in the extended attributes of DEST(s).
                    Equivalent to 'xatag -D <file>...; xatag -c <tag> <file>...'
  -x --execute      Execute a query.

Tag Management Commands:
  -e --enter        Enter TAG into the known tag list.  Adding a tag to 
                    the list will prohibit the warning printed when using an
                    unknown tag.  Known tags are also used for shell
                    completion and interactively choosing tags to apply to a
                    file.
  -m --manage       Manage. 

Argument Flags:
  -t <tag> --tag=<tag>     The following argument is a tag; when used, all
                           other positional arguments will be considered
                           files.
  -f <file> --file=<file>  The following argument is a file; when used, all
                           other positional arguments will be considered

Genreal Options:
  -n --complement                    The -n stands for "not".  Can be used on -d, -l, and -c/-C.
  -q --quiet                         Be as quiet as possible.
  -T --terse                         Only print values for tag keys that have been altered.  
     --debugging                     Print debugging messages.
  -F <fsep> --file-separator=<fsep>  [default: :]
  -K <ksep> --key-separator=<ksep>   [default: :]
  -V <vsep> --val-separator=<vsep>   [default:  ] (a space)
  -k --key-val-pairs
  -o --one-line
  -v --version                       Print version.    
  -h --help                          You managed to find this already.

  
When reading and writing extended attributes, symlinks are followed by default.  
"""

# Not implemented:
#  -L --no-follow-symlinks   Not implemented.  
#     --follow-symlinks      The default.
# The way to do it, if required, is
#     xattr.xattr(path, options=xattr.XATTR_NOFOLLOW)

from docopt import docopt
import os.path

from xatag.operations import *

command_list = [
    "--add",
    "--interactive",
    "--list",
    "--set",
    "--set-all",
    "--delete",
    "--delete-all",
    "--probe",
    "--copy",
    "--copy-over",
    "--execute",
    "--enter",
    "--manage",
    ]

def parse_tags(cli_tags):
    # Tag.from_string returns a list, so explode it
    return [t for tag in cli_tags for t in Tag.from_string(tag)]

def fix_arguments(arguments):
    # When the user manually specifies that an argument is a file or tag, that
    # goes to a separate key.  Make a new list with the values in both keys. 
    files = arguments['--file'] + arguments['<file>']
    tags  = arguments['--tag']  + arguments['<tag>']
    arguments['files'] = files
    arguments['tags']  = parse_tags(tags)
    arguments['source']       = arguments['<src>']
    arguments['destinations'] = arguments['<dest>']
    arguments['fsep'] = arguments['--file-separator']
    arguments['ksep'] = arguments['--key-separator']
    arguments['vsep'] = arguments['--val-separator']

def extract_options(arguments):
    """Make an options dict for passing to the functions that actually do stuff."""
    options = {}
    for key,val in arguments.items():
        if not key in command_list:
            if key.startswith('--'): 
                newkey = key[2:]
            elif key.startswith('-'): 
                newkey = key[1:]
            else:
                newkey = key
            newkey = newkey.replace('-', '_')
            options[newkey] = val
    files_to_print = options['files'] + options['destinations']
    if files_to_print and not ('longest_filename' in options):
        options['longest_filename'] = max(len(f) for f in files_to_print)
    return options
                
def parse_command_line():
    arguments = docopt(__doc__, version='xatag version 0.0.0')
    fix_arguments(arguments)
    command = False
    for c in command_list:
        if c in arguments.keys() and arguments[c]: 
            command = c
            break
    if not command:
        # TODO: test if all the commands are there
        command = ('--add' if arguments['<tag>'] else '--interactive')
    # This works because of convention.  '--some-name' is sent to 'cmd_some_name', which
    # is called with the arguments array.
    command = globals()["cmd_" + command[2:].replace('-', '_')]
    options = extract_options(arguments)
    return (command, options)

# TODO: think of a better name for this
def each_file(options, files=False):
    if not files: files = options['files']
    for f in files:
        if os.path.exists(f):
            # if len(files) > 1: print(f)
            yield f
            # if len(files) > 1: print
        else:
            print("path does not exist: " + f)

def cmd_add(options): 
    for f in each_file(options):
        add_tags(f, **options)
        print_file_tags(f, **options)
        
def cmd_list(options):
    for f in each_file(options):
        print_file_tags(f, subset=True, **options)

def cmd_set(options):
    for f in each_file(options):
        set_tags(f, **options)
        print_file_tags(f, **options)

def cmd_set_all(options):
    for f in each_file(options):
        set_all_tags(f, **options)
        print_file_tags(f, **options)

def validate_source_and_destinations(options):
    source = options['source']
    destinations = []
    for d in options['destinations']:
        if os.path.exists(d):
            destinations.append(d)
        else:
            print("destination path does not exist: " + d)
    if not os.path.exists(source):
        source = False
        print("source path does not exist: " + source)
    options['source'] = source
    options['destinations'] = destinations

def cmd_copy(options):
    validate_source_and_destinations(options)
    if options['source']:
        copy_tags(call_with_destination=lambda d: print_file_tags(d, **options), 
                  **options)

def cmd_copy_over(options):
    source, destinations = validate_source_and_destinations(options)
    if source:
        copy_over_tags(source, destinations, **options)
        for f in each_file(options, files=destinations):
            print_file_tags(f, **options)

def cmd_delete(options):
    for f in each_file(options):
        delete_tags(f, **options)
        print_file_tags(f, **options)
        
def cmd_delete_all(options):
    for f in options['files']:
        delete_all_tags(f)

def cmd_execute(options):
    # When parsing an '--execute' call, everything is put in the array for
    # <tag> no matter what.  A single tag is a valid query string, so let's
    # just call any list of arguments with one element a query.
    if options('--execute'):
        if len(options['<tag>']) == 1:
            options['<query_string>'] = options['<tag>']
            options['<tag>'] = []

if __name__ == '__main__':
    command, options = parse_command_line()
    command(options)


