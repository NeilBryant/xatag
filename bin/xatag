#!/usr/bin/env python

"""xatag - file tagging using extended attributes (xattr).

Usage:
  xatag [-rRLqv ] [-a] <tag>         <file>... 
  xatag [-rRLqv ] [-a] <file>...  -t <tag>...    
  xatag [-rRLqv ] [-a] <tag>...   -f <file>...
  xatag [-rRLqv ] [-i] <file>
  xatag [-rRLqv ]  -l  <file>...
  xatag [-rRLqv ]  -s  <tag>         <file>... 
  xatag [-rRLqv ]  -s  <file>...  -t <tag>...    
  xatag [-rRLqv ]  -s  <tag>...   -f <file>...   
  xatag [-rRLqv ]  -S  <tag>         <file>... 
  xatag [-rRLqv ]  -S  <file>...  -t <tag>...    
  xatag [-rRLqv ]  -S  <tag>...   -f <file>...   
  xatag [-rRLqvn]  -d  <tag>         <file>... 
  xatag [-rRLqvn]  -d  <file>...  -t <tag>... 
  xatag [-rRLqvn]  -d  <tag>...   -f <file>... 
  xatag [-rRLqv ]  -D  <file>...
  xatag [-rRLqv ]  -p  <file>        <tag>...
  xatag [-rRLqv ]  -c  <src> <dest>...
  xatag [-rRLqvn]  -c  <src> <dest>... [-t <tag>]...
  xatag [-rRLqv ]  -C  <src> <dest>...
  xatag [-rRLqvn]  -C  <src> <dest>... [-t <tag>]...
  xatag [-rRLqv ]  -x  <tag>... | <query_string>
  xatag [-rRLqv ]  -e  <tag>...           
  xatag [-rRLqv ]  -m          
  xatag  -h | --help
  xatag  -V | --version

File Tagging Commands:
  -a --add          Add all of the TAG(s) to the FILE(s).  This is the
                    default command if you provide more than one argument.
  -i --interactive  Add and remove tags for FILE interactively.  This is the
                    default command if you provide only one argument.
  -l --list         List the tags currently written on FILE(s).  
  -s --set          Set the tags of the given FILE(s) to the TAG(s) given, erasing 
                    any previous xatag data in the extended attributes in the
                    same fields as new TAG(s).
  -S --set-all      Set the tags of the given FILE(s) to the TAG(s) given, erasing 
                    any previous xatag data in the extended attributes.
                    Equivalent to 'xatag -D <file>...; xatag -a <tag> <file>...'
  -d --delete       Remove all of the given TAG(s) to the given FILE(s).
  -D --delete-all   Remove all xatag tags from the FILE(s)
  -p --probe        Probe for TAG(s) in the given FILE.
  -c --copy         Copy xatag fields from SRC to DEST(s)
  -C --copy-over    Copy xatag fields from SRC to DEST(s), erasing any 
                    previous xatag data in the extended attributes.
                    Equivalent to 'xatag -D <file>...; xatag -c <tag> <file>...'
  -x --execute      Execute a query.
  
Tag Management Commands:

  -e --enter        Enter TAG into the known tag list.  Adding a tag to 
                    the list will prohibit the warning printed when using an
                    unknown tag.  Known tags are also used for shell
                    completion and interactively choosing tags to apply to a
                    file.
  -m --manage       Manage. 

Argument Flags:
  -t <tag> --tag=<tag>     The following argument is a tag; when used, all
                           other positional arguments will be considered
                           files.
  -f <file> --file=<file>  The following argument is a file; when used, all
                           other positional arguments will be considered

Genreal Options:
  -n --complement          The -n stands for "not".
  -r --recursive
  -R --recursive-with-dirs  Recursive, including directories themselves.   
  -L --follow-symlinks
     --no-follow-symlinks
  -q --quiet                Quiet.           
  -v --verbose              Verbose.         
     --debugging            Print debugging messages.
  -V --version              Print version.    
  -h --help                 You managed to find this already.
                              tags.
 
"""

from docopt import docopt
# from schema import Schema, And, Or, Use, SchemaError
import os.path

from xatag.operations import *

command_list = [
    "--add",
    "--interactive",
    "--list",
    "--set",
    "--set-all",
    "--delete",
    "--delete-all",
    "--probe",
    "--copy",
    "--copy-over",
    "--execute",
    "--enter",
    "--manage",
    ]

def parse_tags(cli_tags):
    # Tag.from_string returns a list, so explode it
    return [t for tag in cli_tags for t in Tag.from_string(tag)]

def fix_arguments(arguments):
    # When the user manually specifies that an argument is a file or tag, that
    # goes to a separate key.  Make a new list with the values in both keys. 
    files = arguments['--file'] + arguments['<file>']
    tags  = arguments['--tag']  + arguments['<tag>']
    arguments['files'] = files
    arguments['tags']  = parse_tags(tags)
    arguments['source']       = arguments['<src>']
    arguments['destinations'] = arguments['<dest>']

def extract_options(arguments):
    """Make an options dict for passing to the functions that actually do stuff."""
    options = {}
    for key,val in arguments.items():
        if not key in command_list:
            if key.startswith('--'): 
                newkey = key[2:]
            elif key.startswith('-'): 
                newkey = key[1:]
            else:
                newkey = key
            options[newkey] = val
    return options
                
def parse_command_line():
    arguments = docopt(__doc__, version='xatag version 0.0.0')
    fix_arguments(arguments)
    command = False
    for c in command_list:
        if c in arguments.keys() and arguments[c]: 
            command = c
            break
    if not command:
        # TODO: test if all the commands are there
        command = ('--add' if arguments['<tag>'] else '--interactive')
    # This works because of convention.  '--some-name' is sent to 'cmd_some_name', which
    # is called with the arguments array.
    command = globals()["cmd_" + command[2:].replace('-', '_')]
    options = extract_options(arguments)
    return (command, options)

# TODO: think of a better name for this
def each_file(options, files=False):
    if not files: files = options['files']
    for f in files:
        if os.path.exists(f):
            if len(files) > 1: print(f)
            yield f
            if len(files) > 1: print
        else:
            print("path does not exist: " + f)

def cmd_add(options): 
    for f in each_file(options):
        add_tags(f, **options)
        print_file_tags(f)
        
def cmd_list(options):
    for f in each_file(options):
        print_file_tags(f)

def cmd_set(options):
    for f in each_file(options):
        set_tags(f, **options)
        print_file_tags(f)

def cmd_set_all(options):
    for f in each_file(options):
        set_all_tags(f, **options)
        print_file_tags(f)

def validate_source_and_destinations(options):
    source = options['source']
    destinations = []
    for d in options['destinations']:
        if os.path.exists(d):
            destinations.append(d)
        else:
            print("destination path does not exist: " + dest)
    if os.path.exists(source):
    else:
        source = False
        print("source path does not exist: " + source)
    return (source, destinations)

def cmd_copy(options):
    source, destinations = validate_source_and_destinations(options)
    if source:
        copy_tags(source, destinations, **options)
        for f in each_file(options, files=destinations):
            print_file_tags(f)

def cmd_copy_over(options):
    source, destinations = validate_source_and_destinations(options)
    if source:
        copy_over_tags(source, destinations, **options)
        for f in each_file(options, files=destinations):
            print_file_tags(f)

def cmd_delete(options):
    for f in each_file(options):
        delete_tags(f, **options)
        print_file_tags(f)
        
def cmd_delete_all(options):
    for f in options['files']:
        delete_all_tags(f)

def cmd_execute(options):
    # When parsing an '--execute' call, everything is put in the array for
    # <tag> no matter what.  A single tag is a valid query string, so let's
    # just call any list of arguments with one element a query.
    if options('--execute'):
        if len(options['<tag>']) == 1:
            options['<query_string>'] = options['<tag>']
            options['<tag>'] = []

if __name__ == '__main__':
    command, options = parse_command_line()
    command(options)


